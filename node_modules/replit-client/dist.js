'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/* @flow */

var Promise = require('bluebird');
var EventEmitter = require('events').EventEmitter;

var RETRIES = 7;
var DELAY = 500;
var LANG_EXTS = {
  python: 'py',
  ruby: 'rb',
  php: 'php',
  python3: 'py',
  nodejs: 'js',
  go: 'go',
  java: 'java',
  cpp: 'cpp',
  cpp11: 'cpp',
  c: 'c',
  csharp: 'cs',
  fsharp: 'fs',
  rust: 'rs',
  swift: 'swift',
  react_native: 'js',
  jest: 'js'
};

function mainFile(lang) {
  var file = void 0;
  switch (lang) {
    case 'java':
      file = 'Main';
      break;
    case 'react_native':
      file = 'index';
      break;
    default:
      file = 'main';
  }

  return file + '.' + LANG_EXTS[lang];
}

/*:: type stdout = (output: string) => any*/
/*:: type msg = {data: ?string; error: ?string; command: string; }*/
/*:: type file = {content: string; name: string }*/

var ReplitClient = function (_EventEmitter) {
  _inherits(ReplitClient, _EventEmitter);

  /*:: _host: string; */
  /*:: _port: string; */
  /*:: _language: string; */
  /*:: _authToken: string; */
  /*:: _authFailed: boolean; */
  /*:: _retries: number; */
  /*:: _ws: any; */
  /*:: _stdout: ?stdout; */
  /*:: _msgQueue: Array<msg>; */
  /*:: _msgResolvers: Array<function>; */
  /*:: _connecting: ?Promise; */
  /*:: _pingTimer: number; */
  /*:: _socketCreator: ?function; */
  /*:: _timeout: number; */
  /*:: _handshakeRetries: number; */
  /*:: _ops: Promise; */
  /*:: _evaluating: Promise; */

  function ReplitClient(host /*: string*/
  , port /*: string*/
  , language /*: string*/
  , authToken /*: { msg_mac: string; time_created: number; }*/
  , socketCreator /*: function*/
  , options /*: { timeout: number; }*/
  ) {
    _classCallCheck(this, ReplitClient);

    var _this = _possibleConstructorReturn(this, (ReplitClient.__proto__ || Object.getPrototypeOf(ReplitClient)).call(this));

    _this._host = host;
    _this._port = port;
    _this._language = language;
    _this._authToken = authToken.time_created + ':' + authToken.msg_mac;
    _this._init();
    _this._retries = RETRIES;
    _this._handshakeRetries = RETRIES;
    _this._socketCreator = socketCreator;
    if (options != null) {
      _this._timeout = options.timeout;
    }
    return _this;
  }

  _createClass(ReplitClient, [{
    key: 'connect',
    value: function connect() /*: Promise<ReplitClient>*/{
      if (this._connecting) {
        return this._connecting;
      }

      this._connecting = this._connect();
      return this._connecting;
    }
  }, {
    key: 'disconnect',
    value: function disconnect() /*: Promise<bool>*/{
      var _this2 = this;

      if (!(this._ws && this._ws.readyState === this._ws.OPEN)) {
        return Promise.resolve(true);
      }

      clearTimeout(this._pingTimer);
      return new Promise(function (resolve) {
        _this2._ws.onclose = function () {
          return resolve(true);
        };
        _this2._ws.close();
      });
    }
  }, {
    key: 'write',
    value: function write(str /*: string*/) {
      var _this3 = this;

      if (!this._evaluating || !this._connecting) {
        throw new Error('Must evaluate before writing');
      }

      return this._evaluating.then(function () {
        _this3._sendMessage('input', str);
      });
    }
  }, {
    key: '_schedule',
    value: function _schedule(operation /*: () => Promise */) {
      var _this4 = this;

      this._ops = this._ops.then(function () {
        return _this4._connectOrTry();
      }, function () {
        return _this4._connectOrTry();
      }).then(operation);

      return this._ops;
    }
  }, {
    key: '_startEvaluating',
    value: function _startEvaluating() {
      var _this5 = this;

      var _resolve = void 0;
      this._evaluating = new Promise(function (r) {
        return _resolve = r;
      });
      return {
        resolve: function resolve() {
          setTimeout(function () {
            return _resolve();
          }, 0);
        },


        stop: function stop() {
          _this5._evaluating = null;
        }
      };
    }
  }, {
    key: 'evaluate',
    value: function evaluate(code /*: string*/
    , _ref /*: { stdout: ?stdout }*/
    ) /*: Promise<{
       error: ?string;
       data: ?string;
       }>*/
    {
      var _this6 = this;

      var stdout = _ref.stdout;

      var ev = this._startEvaluating();
      return this._schedule(function () {
        _this6._stdout = stdout;
        _this6._sendMessage('eval', code);
        ev.resolve();
        return _this6._waitForResult().then(function (result) {
          ev.stop();
          return result;
        });
      });
    }
  }, {
    key: 'lint',
    value: function lint(code /*: string*/
    ) /*: Promise<{
       error: ?string;
       data: ?string;
       }>*/
    {
      var _this7 = this;

      return this._schedule(function () {
        _this7._sendMessage('lint', code);
        return _this7._waitForLintResult().then(function (result) {
          if (result.data === '') {
            // This is most likely because it was "skipped" (see reset).
            result.data = [];
            return result;
          }

          result.data = parseJSON(result.data);

          return result;
        });
      });
    }
  }, {
    key: 'evaluateOnce',
    value: function evaluateOnce(code /*: string*/
    , options /*: ?{
              stdout: ?stdout,
              timeout: ?{
              time: number,
              callback: () => bool
              }
              }*/
    ) /*: Promise<{
       error: ?string;
       data: ?string;
       }>*/
    {
      var _this8 = this;

      return new Promise(function (resolve, reject) {
        var req = new XMLHttpRequest();

        var t = null;
        if (options != null && options.timeout) {
          var timeout = options.timeout;
          var callback = function callback() {
            // this is just to make flow happy
            var stop = timeout.callback();
            if (stop) {
              req.abort();
              reject(new Error('Aborted'));
            } else {
              t = setTimeout(callback, timeout.time);
            }
          };
          t = setTimeout(callback, timeout.time);
        }

        req.onload = function () {
          if (req.status !== 200) {
            clearTimeout(t);
            reject(new Error(req.responseText));
          } else {
            var _data /*: Array<msg>*/ = [];
            try {
              _data = parseJSON(req.responseText);
            } catch (e) {
              clearTimeout(t);
              reject(e);
              return;
            }
            _data.forEach(function (msg) {
              if (msg.command === 'output') {
                if (options && options.stdout != null) {
                  options.stdout(msg.data);
                }
              } else if (msg.command === 'result') {
                clearTimeout(t);
                resolve(msg);
              }
            });
          }
        };

        var protocol = 'http';
        var port = _this8._port;
        if ((typeof location === 'undefined' ? 'undefined' : _typeof(location)) === 'object' && location.protocol === 'https:') {
          protocol = 'https';
          if (port === 80 || port === '80') {
            port = 443;
          }
        }

        req.open('POST', protocol + '://' + _this8._host + ':' + port + '/eval', true);

        req.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded; param=value');

        var data = '';
        data += 'auth=' + encodeURIComponent(_this8._authToken);
        data += '&language=' + encodeURIComponent(_this8._language);
        data += '&code=' + encodeURIComponent(code);

        req.send(data);
      });
    }
  }, {
    key: '_waitUntilReady',
    value: function _waitUntilReady() {
      var _this9 = this;

      return this._nextMessage().then(function (msg) {
        if (msg.command === 'ready') {
          return msg;
        }

        return _this9._waitUntilReady();
      });
    }
  }, {
    key: 'stop',
    value: function stop() /*: Promise*/{
      return this._reset('stop');
    }
  }, {
    key: 'reset',
    value: function reset() /*: Promise*/{
      return this._reset('reset');
    }
  }, {
    key: '_emptyQueue',
    value: function _emptyQueue() {
      var resolver = void 0;
      while (resolver = this._msgResolvers.shift()) {
        try {
          resolver({ command: 'skip' });
        } catch (e) {
          // ignore.
        }
      }
    }
  }, {
    key: '_reset',
    value: function _reset(message /*: string*/) /*: Promise*/{
      var _this10 = this;

      this._emptyQueue();

      return this._schedule(function () {
        _this10._sendMessage(message);
        _this10._emptyQueue();
        return _this10._waitUntilReady().then(function (msg) {
          if (msg.command !== 'ready') {
            throw new Error('Expected ready after reset');
          }
        });
      });
    }
  }, {
    key: 'fileChanges',
    value: function fileChanges() {
      this._sendMessage('changedFiles', '');
    }
  }, {
    key: 'fileContents',
    value: function fileContents(path /*: string */)
    /*: Promise<{
      error: ?string;
      data: ?string;
      }>*/
    {
      var _this11 = this;

      return this._schedule(function () {
        _this11._sendMessage('fileContents', path);

        return _this11._waitForFileResult();
      });
    }
  }, {
    key: 'removeFile',
    value: function removeFile(path /*: string */)
    /*: Promise<{
      error: ?string;
      data: ?string;
      }>*/
    {
      var _this12 = this;

      return this._schedule(function () {
        _this12._sendMessage('removeFile', path);
        return _this12._waitForRemoveFileResult();
      });
    }
  }, {
    key: 'runProject',
    value: function runProject(files /*: Array<file>*/
    , _ref2 /*: { stdout: ?stdout }*/
    ) /*: Promise<{
         error: ?string;
         data: ?string;
         }>*/
    {
      var _this13 = this;

      var stdout = _ref2.stdout;

      var ev = this._startEvaluating();
      return this._schedule(function () {
        _this13._stdout = stdout;
        // Need to stringify files because 'data' field is expected
        // to be string and not array.
        _this13._sendMessage('runProject', JSON.stringify(files));

        ev.resolve();

        return _this13._waitForResult().then(function (result) {
          ev.stop();
          return result;
        });
      });
    }
  }, {
    key: 'runUnitTests',
    value: function runUnitTests(_ref3 /*: {
                                       files: Array<file>,
                                       suiteCode: string,
                                       } */) /*:
                                             Promise<{
                                             error: ?string;
                                             passed: bool;
                                             failures: Array<{ name: string; stack: string; }>;
                                             }>
                                             */{
      var _this14 = this;

      var files = _ref3.files,
          suiteCode = _ref3.suiteCode;

      var ev = this._startEvaluating();
      return this.reset().then(function () {
        // Need to stringify files because 'data' field is expected
        // to be string and not array.
        _this14._sendMessage('runUnitTests', JSON.stringify({
          files: files,
          suiteCode: suiteCode
        }));

        ev.resolve();
        return _this14._waitForResult().then(function (result) {
          ev.stop();

          var data = void 0;
          if (result.data) {
            data = parseJSON(result.data);
          } else {
            data = { passed: false, failures: [] };
          }
          return {
            passed: data.passed,
            failures: data.failures,
            error: result.error
          };
        });
      });
    }
  }, {
    key: 'runSingleUnitTests',
    value: function runSingleUnitTests(_ref4 /*: {
                                             code: string,
                                             suiteCode: string,
                                             }*/
    ) {
      var code = _ref4.code,
          suiteCode = _ref4.suiteCode;

      var files = [{
        name: mainFile(this._language),
        content: code
      }];

      return this.runUnitTests({
        files: files,
        suiteCode: suiteCode
      });
    }
  }, {
    key: 'debug',
    value: function debug(code /*: string*/
    , _ref5 /*: { stdout: ?stdout }*/
    ) /*: Debugger */{
      var stdout = _ref5.stdout;

      var loading = this.reset();
      this._stdout = stdout;
      var debug = new Debugger(this, loading, code);
      this._ops = loading.then(function () {
        return new Promise(function (resolve) {
          debug.on('done', function () {
            return resolve();
          });
        });
      });

      return debug;
    }
  }, {
    key: '_init',
    value: function _init() {
      this._ws = null;
      this._stdout = null;
      this._evaluating = null;

      this._msgQueue = [];
      this._msgResolvers = [];
      this._ops = Promise.resolve();
    }
  }, {
    key: '_nextMessage',
    value: function _nextMessage() /*: Promise*/{
      var _this15 = this;

      return new Promise(function (resolve) {
        if (_this15._msgQueue.length) {
          resolve(_this15._msgQueue.shift());
        } else {
          _this15._msgResolvers.push(resolve);
        }
      });
    }

    // This will make sure we at least try to connect
    // and not get stuck in some past error.
    // use case is what if we were disconnected from the internet
    // and now we are connected.

  }, {
    key: '_connectOrTry',
    value: function _connectOrTry() /*: Promise<ReplitClient> */{
      var _this16 = this;

      return this.connect().catch(function () {
        _this16._connecting = null;
        return _this16.connect();
      });
    }
  }, {
    key: '_handshakeRetry',
    value: function _handshakeRetry(resolve /*: function */, reject /*: function */) {
      this._init();
      this._handshakeRetries -= 1;

      if (this._handshakeRetries < 1) {
        return reject(new HandshakeError('Handshake error'));
      }

      this._connect().then(resolve, reject);
    }
  }, {
    key: '_connect',
    value: function _connect() /*: Promise<ReplitClient>*/{
      var _this17 = this;

      return new Promise(function (resolve, reject) {
        _this17.emit('connecting');

        var protocol = 'ws';
        var port = _this17._port;
        if ((typeof location === 'undefined' ? 'undefined' : _typeof(location)) === 'object' && location.protocol === 'https:') {
          protocol = 'wss';
          if (port === 80 || port === '80') {
            port = 443;
          }
        }

        var url = protocol + '://' + _this17._host + ':' + port + '/ws';
        _this17._ws = _this17._socketCreator ? _this17._socketCreator(url) : new WebSocket(url);

        var timedout = false;
        var timer = void 0;
        if (_this17._timeout) {
          timer = setTimeout(function () {
            timedout = true;
            var err = new TimeoutError('Timed out on connecting');
            reject(err);
            _this17.disconnect();
          }, _this17._timeout);
        }

        _this17._ws.onopen = function () {
          _this17._ws.onclose = _this17._handshakeRetry.bind(_this17, resolve, reject);

          // TODO: if we disconnect in a handshake (e.g. faulty server) we should
          // have retry logic.
          _this17._handshake().then(function () {
            if (timedout) {
              _this17.disconnect();
              return;
            }

            _this17._ws.onclose = _this17._closeHandler.bind(_this17);
            clearTimeout(timer);
            // Reset retries.
            _this17._retries = RETRIES;
            resolve(_this17);
            _this17.emit('connected');
          }, function (err) {
            reject(err);
            _this17._ws.onclose = null;
            _this17.disconnect();
          });
        };
        _this17._ws.onclose = function (e) {
          if (timedout) {
            return;
          }

          reject(new Error(errMsgFromCloseEvent(e)));
        };
        _this17._ws.onmessage = _this17._messageHandler.bind(_this17);
      });
    }
  }, {
    key: '_handshake',
    value: function _handshake() /*: Promise */{
      var _this18 = this;

      this._sendMessage('auth', this._authToken);
      return this._nextMessage().then(function (msg) {
        if (msg.command !== 'auth_result') {
          throw new Error('Expected "auth_result" command: ' + msg.command);
        }
        if (msg.data !== 'true') {
          _this18._authFailed = true;
          throw new Error('Failed to auth');
        }
        _this18._sendMessage('select_language', _this18._language);
        return _this18._nextMessage();
      }).then(function (msg) {
        if (msg.command !== 'ready') {
          _this18._authFailed = true;
          if (msg.command === 'error') {
            throw new Error(msg.data);
          }
          throw new Error('Expected "ready" command but got: ' + msg.command);
        }

        _this18._ping();
      });
    }
  }, {
    key: '_sendMessage',
    value: function _sendMessage(command /*: string*/) {
      var data /*: string*/ = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';

      var msg = { command: command, data: data };
      this._ws.send(JSON.stringify(msg));
    }
  }, {
    key: '_messageHandler',
    value: function _messageHandler(e /*: {data: string} */) {
      var msg = parseJSON(e.data);

      if (msg.command === 'pong') {
        this._ping();
        return;
      } else if (msg.command === 'ping') {
        this._pong();
        return;
      } else if (msg.command === 'output') {
        if (this._stdout != null) {
          this._stdout(msg.data);
        }
        return;
      } else if (msg.command === 'files') {
        this.emit('files', msg);
        return;
      } else if (msg.command === 'clearConsole') {
        this.emit('clearConsole');
        return;
      }

      if (this._msgResolvers.length) {
        var resolver = this._msgResolvers.shift();
        resolver(msg);
      } else {
        this._msgQueue.push(msg);
      }
    }
  }, {
    key: '_waitForLintResult',
    value: function _waitForLintResult() /*: Promise<msg>*/{
      return this._nextMessage().then(function (msg) {
        if (msg.command === 'skip') {
          return { command: 'lintResult', data: '' };
        }

        if (msg.command !== 'lintResult') {
          throw new Error('Expected lintResult but got: ' + msg.command);
        }

        return msg;
      });
    }
  }, {
    key: '_waitForResult',
    value: function _waitForResult() /*: Promise<msg>*/{
      var _this19 = this;

      return this._nextMessage().then(function (msg) {
        switch (msg.command) {
          case 'result':
            return msg;
          case 'input':
            return _this19._waitForResult();
          case 'skip':
            return { command: 'result', data: '' };
          // output is handled by the message handler since it can happen
          // outside the eval loop (e.g. nodejs settimeout)
        }

        throw new Error('Unexpected command: ' + msg.command);
      });
    }
  }, {
    key: '_waitForFileResult',
    value: function _waitForFileResult() /* Promise<msg>*/{
      return this._nextMessage().then(function (msg) {
        // file contents are sent with command `file:<filename>`
        if (msg.command.startsWith('file:')) {
          return msg;
        }

        throw new Error('expecting file result not: ' + msg.command);
      });
    }
  }, {
    key: '_waitForRemoveFileResult',
    value: function _waitForRemoveFileResult() /* Promise<msg>*/{
      return this._nextMessage().then(function (msg) {
        if (msg.command === 'removeFile') {
          return msg;
        }

        throw new Error('expected removeFile, not: ' + msg.command);
      });
    }
  }, {
    key: '_closeHandler',
    value: function _closeHandler(e /*: CloseEvent | TimeoutError */) {
      var _this20 = this;

      this._init();
      this._retries -= 1;
      clearTimeout(this._pingTimer);

      if (this._authFailed) {
        this._retries = 0;
      }

      if (this._retries < 1) {
        this.emit('disconnected', { retry: false });
        this._connecting = null;
        this._retries = 0;
        return Promise.reject(e);
      } else {
        var delay = (RETRIES - this._retries) * DELAY;
        this.emit('disconnected', { retry: true, delay: delay });
        this._connecting = new Promise(function (resolve, reject) {
          setTimeout(function () {
            return _this20._connect().then(resolve, reject);
          }, delay);
        });
        return this._connecting.catch(function (e) {
          return _this20._closeHandler(e);
        });
      }
    }
  }, {
    key: '_ping',
    value: function _ping() {
      var _this21 = this;

      this._pingTimer = setTimeout(function () {
        _this21._sendMessage('ping');
      }, 10 * 1000);
    }
  }, {
    key: '_pong',
    value: function _pong() {
      this._sendMessage('pong');
    }
  }]);

  return ReplitClient;
}(EventEmitter);

/*:: type stackRecord = { functionName: string; lineNo: number;}*/

/**
 * debug = Debugger(client);
 * debug.step().then(..) // returns {stack, done}
 * debug.result().tnen(..) // returns result
 */


var Debugger = function (_EventEmitter2) {
  _inherits(Debugger, _EventEmitter2);

  /*:: _client: ReplitClient; */
  /*:: _ready: Promise<msg>; */
  /*:: _stack: Array<stackRecord> */

  function Debugger(client, loading, code) {
    _classCallCheck(this, Debugger);

    var _this22 = _possibleConstructorReturn(this, (Debugger.__proto__ || Object.getPrototypeOf(Debugger)).call(this));

    _this22._client = client;
    _this22._stack = [];

    _this22._ready = loading.then(function () {
      _this22._client._sendMessage('debuggerStart', code);
      return _this22._client._nextMessage();
    }).then(function (msg) {
      if (msg.command !== 'debuggerReady') {
        throw new Error('Expected debuggerReady message');
      }
    });
    return _this22;
  }

  _createClass(Debugger, [{
    key: 'step',
    value: function step() /*: Promise<{
                              done: boolean;
                              stack: Array<stackRecord>;
                              }>*/
    {
      var _this23 = this;

      return this._ready.then(function () {
        _this23._client._sendMessage('debuggerStep');
        return _this23._client._nextMessage();
      }).then(function (msg) {
        if (msg.command !== 'debuggerBreak') {
          throw new Error('Expected debuggerBreak message');
        }
        var info = parseJSON(msg.data);
        _this23._stack = info.stack;
        return info;
      });
    }
  }, {
    key: 'stepOver',
    value: function stepOver() /*: Promise<{
                                  done: boolean;
                                  stack: Array<stackRecord>;
                                  }>*/
    {
      var _this24 = this;

      if (this._stack.length === 0) {
        // First call nothing to step over.
        return this.step();
      }

      var currentStack = this._stack;
      var stepUntil = function stepUntil() {
        return _this24.step().then(function (info) {
          if (info.done) {
            return info;
          }

          if (info.stack.length === currentStack.length || info.stack.length < currentStack.length) {
            return info;
          }

          return stepUntil();
        });
      };

      return stepUntil();
    }
  }, {
    key: 'stepOut',
    value: function stepOut() /*: Promise<{
                                 done: boolean;
                                 stack: Array<stackRecord>;
                                 }>*/
    {
      var _this25 = this;

      // Note: if this is the first call (i.e. stack.length is 0) it will step
      // through the entire program which is probably expected?
      var currentStack = this._stack;
      var stepUntil = function stepUntil() {
        return _this25.step().then(function (info) {
          if (info.done) {
            return info;
          }

          if (info.stack.length < currentStack.length) {
            return info;
          }

          return stepUntil();
        });
      };

      return stepUntil();
    }
  }, {
    key: 'resume',
    value: function resume() /*: Promise<{ error: ?string; data: ?string; }>*/{
      var _this26 = this;

      var stepUntil = function stepUntil() {
        return _this26.step().then(function (info) {
          if (info.done) {
            return _this26.result();
          }
          return stepUntil();
        });
      };

      return stepUntil();
    }
  }, {
    key: 'result',
    value: function result() /*: Promise<{ error: ?string; data: ?string; }>*/{
      var _this27 = this;

      return this._ready.then(function () {
        return _this27._client._nextMessage();
      }).then(function (msg) {
        if (msg.command !== 'result') {
          throw new Error('Expected debuggerResult message');
        }
        return msg;
      }).finally(function () {
        _this27.emit('done');
      });
    }
  }]);

  return Debugger;
}(EventEmitter);

function errMsgFromCloseEvent(e) {
  var msg = e.reason || e.type || '';
  if (e.code) {
    msg += ': ' + e.code;
  }
  return msg;
}

function parseJSON(json) {
  try {
    return JSON.parse(json);
  } catch (e) {
    throw new JSONParseError('Error parsing: ' + json + '\n' + e.message);
  }
}

var TimeoutError = function (_Error) {
  _inherits(TimeoutError, _Error);

  function TimeoutError(message) {
    _classCallCheck(this, TimeoutError);

    var _this28 = _possibleConstructorReturn(this, (TimeoutError.__proto__ || Object.getPrototypeOf(TimeoutError)).call(this, message));

    _this28.name = 'TimeoutError';
    return _this28;
  }

  return TimeoutError;
}(Error);

var HandshakeError = function (_Error2) {
  _inherits(HandshakeError, _Error2);

  function HandshakeError(message) {
    _classCallCheck(this, HandshakeError);

    var _this29 = _possibleConstructorReturn(this, (HandshakeError.__proto__ || Object.getPrototypeOf(HandshakeError)).call(this, message));

    _this29.name = 'HandshakeError';
    return _this29;
  }

  return HandshakeError;
}(Error);

var JSONParseError = function (_Error3) {
  _inherits(JSONParseError, _Error3);

  function JSONParseError(message) {
    _classCallCheck(this, JSONParseError);

    var _this30 = _possibleConstructorReturn(this, (JSONParseError.__proto__ || Object.getPrototypeOf(JSONParseError)).call(this, message));

    _this30.name = 'JSONParseError';
    return _this30;
  }

  return JSONParseError;
}(Error);

module.exports = ReplitClient;

